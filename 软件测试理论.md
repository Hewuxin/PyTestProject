## 软件测试

### $\color{red}所有自动化的最终目标:无人值守测试$

### $\color{red}所有的测试执行(计算机完成) --发版--回退--部署--监控--预警$

### 定义

> 使用人工或自动的手段来运行或者测试某个系统的过程

### 目的：

- 以最小的人力、物力和时间找出软件中潜在的错误和缺陷

1. 检验产品是否满足规定的需求；弄清**$\color{red}预期结果$和$\color{red}实际结果$**的差别
2. 为了提高用户的体验
3. 为了发现程序中存在代码或业务逻辑的错误

## 软件测试原则

- 证明软件中存在缺陷
- **不能穷尽测试**
- 测试应该尽早介入
- 28原则
- 不存在缺陷谬论
- 妥善保存一切文档

## 软件测试基本要求

1. 外观界面测试
2. 易用性测试
3. 兼容性测试
4. 安全性测试
5. 性能测试
6. 功能测试 功能是否正常运行

## 软件测试的工作流程

> 需求分析--->需求评审--->编写测试计划--->测试计划评审--->提取测试点--->设计测试用例--->测试用例评审--->搭建测试环境--->冒烟测试--->执行测试用例--->bug跟踪处理--->测试报告

1. 需求分析

   阅读需求文档 产品文档 产品详细设计说明书 分析需求的点 参数需求评审

   快速熟悉项目 

2. 测试计划和测试方案

   测试计划：测试整个项目的总体的规划

   测试的范围，进度的安排 人力物力的安排 整体的测试策略 风险的评估 风险的规避 5w 1h why when who  what where

   测试方案  how 

   被测试的目标 选取什么样的测试工具 测试的方法 测试的重点

3. 测试用例设计

   边界值  等价类。。。

4. 测试用例执行

5. 评估阶段 测试报告

## 软件开发过程模型

1. #### 瀑布模型

   **文档驱动**，遵守这个约束可使软件维护变得比较容易一些，从而显著降低软件预算。

   1. 流程

      > 需求分析-->设计-->编码-->实现-->软件测试-->完成-->维护

   2. 测试的切入点

      > 测试阶段处于软件实现后，必须在代码完成后留出足够的测试时间，否则将导致测试不充分，很多问题到项目后期才会暴露

   3. 优缺点

      > 优点： 开发的各个阶段比较清晰；
      >
      > ​             强调早起计划和需求调查；
      >
      > ​              适合需求稳定的产品开发。
      >
      > ​              可在迭代模型中应用瀑布模型
      >
      > 缺点： 依赖早期的需求调查，不适应需求的变化；
      >
      > ​             不适合需求模糊或者需求经常变动的系统
      >
      > ​             单一流程不可逆；
      >
      > ​             风险往往在后期才会显露，失去及早纠正的机会，影响后面的阶段，可能会导致项目失败。

2. #### V模型

   1. 流程

      > 需求分析(验收测试)--->概要设计(系统测试)--->详细设计(集成测试)--->编码(单元测试)

     2. 优缺点

        > 优点： 每一个阶段都清晰明了，便于控制开发的每一个过程，既包含单元测试又包含系统测试
        >
        > 缺点：测试介入的较晚，对于前期的一些缺陷无法发现和修改，测试和开发传行，总用时较长。

3. #### W模型

   测试伴随整个软件开发周期，并且测试的对象不仅仅是程序，需求和设计同样要测试。

   1. 流程

      > 需求分析(验收/系统测试设计)--->概要设计(集成测试设计)--->详细设计(单元测试设计)--->编码(单元测试)--->集成(集成测试)--->实施(系统测试)--->交付(验收测试)

     2. 优缺点
   
        1. 优点：测试伴随软件的整个生命周期。
        2. 缺点：
           1. 依赖于软件开发和软件测试，依然保持一前一后的线性关系，无法支持迭代、自发性和需求等变更调整；
           2. 对于当前很多项目，在执行的过程中根本不产生文档，那么W模型基本无法适用；
           3. 使用起来技术复杂度很高，对于需求和设计的测试要求很高，实践起来困难。适用于大中型企业。

4. 螺旋开发模型

   1. 流程

      > 制定计划(决定目标、方案和限制)--->风险分析(评价方案、识别风险、消除风险)--->实施工程(开发、验证下一代产品)--->客户评估
      >
      > 制定计划-分线分析-原型-软件需求-需求确认-开发计划-评审

5. 敏捷开发模型

   简单设计，快速实现、根据用户需求迭代

6. 迭代开发模型

   先开发小版本 之后逐渐增加功能

## 测试与开发的关系

- 目标相同
  - 都是为了制造出高质量的软件
- 相辅相成 
  - 开发经验对测试有用，测试经验对开发有用
- 侧重点不同：
  - 开发偏向于从无到有的业务逻辑
  - 测试偏移想保证从有到优的业务稳定性
  - 思维定势、测试力度、关注度

## 软件测试分类

### 1. 按测试阶段划分

#### 单元测试

- 编码完成前或后，写完一个方法、函数、类、模块后验证

- 开发人员、白盒测试人员

#### 集成测试

- 单元测试完成之后

- 模块完成编码之后

- 模块和模块之间的测试

- 开发人员、白盒测试人员

#### 系统测试

- 集成测试完成之后

- 程序、软件、app系统

- 整体测试

- 开发、白盒测试、黑盒测试

#### 验收测试（交付测试）

- 系统测试之后

- 整个的系统

### 2. 按是否覆盖源代码划分

#### 白盒测试： 

- 针对代码去测试，覆盖源码

- 语句覆盖

  确保代码里的每一个语句都会被测到

- 判断覆盖

  确保代码里的每一个判断都会被测到

- 条件覆盖

  确保代码里的每一个条件都会被测到

- 路径覆盖

  确保代码里每一个分支都会走到

#### 黑盒测试：

针对功能区测试，完全不关心源码，只关注输入和输出

##### 功能测试

不关心代码怎么实现，只关心有没有问题

- UI(界面)测试
- 业务(功能)测试
- 文档测试
  - 逻辑是否清晰
  - 语言描述是否清晰
  - 引导误导功能
- 易用性测试
- 安装和卸载测试
- 兼容性测试
  - 浏览器测试
  - 平台测试
  - 本身的兼容性
  - 其他的软件的兼容性
  - 数据兼容

##### 性能测试

- 一般性能测试
  - 响应速度
  - 对资源的利用
- 稳定性测试
- 负载测试
- 压力测试

#### 灰盒测试

关心输入、输出，考虑程序运行的状态

### 3. 按是否运行划分

- 静态测试： 测需求文档、界面等不运行测试
  - 测试程序的机构
  - 程序过程
  - 接口是否正常
  - 代码的风格是否符合标准
- 动态测试 ：程序运行中测试

### 4. 其他分类

#### 回归测试

测出问题后，打回去让开发人员修改，开发人员修改提交之后，再进行测试

对软件的既有功能进行验证，以**确保新的开发、修复或修改**不会对软件的**现有功能产生负面影响**

#### 冒烟测试 

开发完成程序之后对程序的主流程(基本功能)进行测试，不测程序的细节

**基本功能基本模块**能否正常运行

#### 随机测试 

monkey测试

- 模拟猴子进行测试，随机位置自由测试

又叫探测性测试，选取重要的功能模块进行测试

#### 验收测试 

- $\alpha$ 测试  是内测版本，公司内部测试
- $\beta$测试：是公测版本，客户测试
- $\gamma$测试：指的是软件版本正式发行的候选版

### 5. 按是否自动化划分

1. 手工测试
2. 自动化测试

## 测试用例

### 定义

test case 是为某个特殊目标而编制的一组==**测试输入**，**执行条件以及预期结果**==，以便测试某个程序路径或核实是否满足某个特定需求。

### 测试用例的特性

有效性

- 测试用例的能够被使用，且被不同人员使用测试**结果一致**。

可复用性

- 良好的测试用例具有重复使用的功能，如：回归测试

易组织性

- 好的测试用例会分门别类地提供给测试人员参考和使用

可评估性

- 从测试管理的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准。

可管理性

- 从测试管理的角度，测试用例的通过率和软件缺陷的数目是软件产品质量好坏的测试标准。

### 测试用例的要素

| 测试用例编号 | 测试项目(测试模块) | 预置（前提条件）条件 | 测试输入 | 预期输出 | 操作步骤       | 测试用例标题         | 级别 |
| :----------- | ------------------ | -------------------- | -------- | -------- | -------------- | -------------------- | ---- |
| ST-子项名-01 | 用户登录           | 邮箱正常使用         | 邮箱     | 正常登录 | 输入邮箱并确认 | 测试能否邮箱登录成功 | 重要 |

测试用例八大要素

1. 测试用例编号

   编号由字符和数字组合成的字符串，用例编号具有**唯一性、容易识别**

2. 测试项目/模块

   测试的模块输入那个项目或者被测试的需求、被测的模块、被测的单元等等

3. 预置条件

   **执行当前测试用例需要的前提条件**，如果前提条件不满足，则后面的测试步骤不能进行或者得不到预期结果

4. 测试输入

   测试用例执行过程中需要加工的外部信息。根据测试用例的具体条件有手工输入、数据库等

5. 预期输出

   测试用例的预期输出结果，包括**返回值内容，界面相应结果**等

   预期结果来源：分析需求文档，根据需求写

6. 操作步骤

   执行当前测试用例需要经过的操作步骤，需要**明确的给出一个步骤的描述**，测试用例执行人员可以根据该步骤完成测试用例执行

7. 测试用例标题

   对测试用例的简单描述。用概括性的语言描述该测试用例的测试点。每个测试用例的标题不能够重复，因为每个测试用例的测试点是不一样的。

8. 级别

   对于测试用例的重要程度的区分，包含如下几种：

   - 高级别：保证系统基本功能、核心业务、重要特性、实际使用频率比较高的用例
   - 中级别：重要程度介于高和低之间的测试用例
   - 低级别：实际使用的频率不高，对系统业务功能影响不大的模块或功能的测试用例

9. 其他要素
   - 用例的设计者：能够准确找到测试用例的设计人员，对用例修改时能方便找到人员。
   - 用例设计日期：方便检查用例的设计进度。
   - 对应的开发人员：出现bug 后能及时找到对应的人员进行修复 ==必写==
   - 测试结果：执行用例最后执行的结果，包括pass、fail、block  ==必写==
   - 测试类型：功能、性能、压力等
   - 测试版本：

### 测试用例的设计原则

- 明确性

  测试人员要尽量避免测试用例存在含糊的因素，在测试过程中，测试用例的测试结果是唯一的。

- 代表性

  尽量将具有相似功能的测试用例抽象合并，功能相似的用例要合并。

- 简洁性

  测试用例简洁，可读性良好，测试过程目的明确，测试结果唯一。测试用例要用陈述性语句 一句话直指问题的核心，不要使用浮夸的修饰手法。

**测试用例要素是为了便于快速的设计测试用例，因此要掌握最常用的八大要素，之后灵活添加其他测试的元素**

### 测试用例设计方法

#### 等价类

- 是把**所有可能的输入数据**，即程序的输入域划**分成若干部分**，然后从每一部分中选取**少数具有代表性的数据**作为**测试**用例。使用等价类划分方法设计测试用例要经历==**划分等价类(列出等价类表)**==和==**选取测试用例**==两步。它将不能穷举的测试过程进行**合理分类**，从而保证设计出来的测试用例具有==**完整性和代表性**==。

- 是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，具有等价特性。

$\color{red}理想的测试是：用最少的测试数据，达到最好的测试质量$

**合理假设**

- 测试某价类的代表值就等于对这一类其它值的测试。

##### 1. 有效等价类

指对**程序的规格说明**来说是==合理的、有意义的输入数据构成的集合==。利用有效等价类可以检验程序是否实现了规格说明中所规定的功能和性能。

##### 2. 无效等价类

是指对**程序的规格说明**是==不合理的、无意义的输入数据所构成的集合==。对于具体的问题，无效等价类**至少有应有一个，也可能有多个**。利用无效等价类可校验程序对于无效数据的处理能力，检测程序的健壮性、容错能力。

> 设计测试用例时，要同时考虑这两种等价类。因为软件不仅要能接收合理的数据，也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性。

##### 案例

qq登录  6-10位的qq 包括6位  包括10位

必须是整数数字 不能以0开头

- 等价类划分

  - 有效等价类
    - 6位 7位 8位 9位 10位 (不以0开头)

  - 无效等价类 （没在设计需求内，都可以理解为无效等价类）
    - 6位 7位 8位 9位 10位 (以0开头)
    - 小数 字母 特殊字符 *&_? 汉字 
    - 数字、小数、字母、特殊字符、汉字的组合
  - 编写测试用例

#### 边界值

**大量的错误是发现在输入或输出范围的边界上**，而不是发生在输入输出范围的内部

1. 概念：边界值分析法是作为对等价类划分法的补充，对输入或输出的边界值进行测试

2. 与等价类的区别：
   1. 边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件；
   2. 边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。

3. 常见的边界值

   ![image-20240330162414984](./images/理论 边界值.png)

#### 因果图法

**定义**

是一种利用图解法分析**输入**的**各种组合**情况，从而设计测试用例的方法，适合于检查程序输入条件的各种组合情况

**特点**

- 考虑输入条件的相互制约及组合关系
- 考虑输出条件对输入条件的依赖关系

##### 核心

因果图法比较适合输入条件比较多的情况，测试所有的输入条件的排列组合，所谓的原因就是输入，所谓的结果就是输出。‘因’=输入条件“果”=输出结果

##### 主要考虑内容

1. 所有输入/输出itoa见的相互制约关系以及组合关系
2. 输入条件的依赖关系，也就是什么样的输入组合会产生什么样 的输出结果，即“因果关系”

##### 符号

1. 恒等  若原因出现，则结果出现；若原因不出现，则结果也不出现
2. 非(~)  若原因出现，则结果不出现；若原因不出现，则结果出现
3. 或(V)  若几个原因中有一个及以上出现，则结果出现；若几个原因都不出现，则结果不出现
4. 与      若其中一个原因不出现，则结果不出现。

##### 因果图法步骤

1. 找出所有的原因，原因即输入条件或输入条件的等价类
2. 找出所有的结果，结果即输出条件
3. 明去所有输入条件之间的制约关系以及组合关系，哪些条件不能组合到一起，哪些条件可以组合到一起
4. 明确所有输出条件之间的制约关系以及组合关系，哪些输出结果不能同时输出，哪些输出结果可以同时输出
5. 找出什么样的输入条件组合会产生哪种输出结果。
6. 把因果图转换成判定表/决策表。
7. 为判定表/决策表中的每一列表示的情况设计测试用例。

##### 案例

系统需求

- 系统只接收50或100元纸币，一次只能使用一张纸币，一次充值金额只能为50元或100元；
- 若输入50元纸币，并选择充值50元，完成充值后退卡，提示充值成功；
- 若输入50元纸币，并选择充值100元，提示输入金额不足，并退回50元；
- 若输入100元纸币，并选择充值50元，完成充值后退卡，提示充值成功，找零50元；
- 若输入100元纸币，并选择充值100元，完成充值后退卡，提示充值成功；
- 若输入纸币后在规定时间内不选择充值按钮，退回输入的纸币，并提示错误；
- 若选择充值按钮后不输入纸币，提示错误

实现步骤：

> https://blog.csdn.net/weixin_43090420/article/details/90608526

<img src="./images/因果图分析.png" alt="image-20240330170730759" style="zoom: 33%;" />

<img src="./images/因果图法测试用例.png" alt="image-20240330170635327" style="zoom:33%;" />

#### 场景法

从起点，通过一系列操作步骤(事件)，达成某一结果，到终点的过程测试。场景法主要用于**冒烟测试**。

1. 场景法是模拟用户操作软件时的场景，主要用于测试系统的业务流程；
2. 当拿到一个测试任务后，先关注它的主要功能和业务流程是否正确实现，这就需要用到场景法来完成测试。当业务流程或者说该软件的主要功能没有问题时，我们再重点从边界值、等价类等方面对控件进行更加细致。完整的测试。
3. 冒烟测试主要采用场景法进行测试。

#### 错误推断法

1. 错误推断法是指利**用直觉和经验**猜测出会出错的可能类型，有**针对性的**列举出程序中所有可能的错误和容易发生错误的情况。
2. 不单独使用，可以作为其他方法的补充。
3. 使用场景： 适用于项目时间比较短，任务比较繁重的情况下，而且测试经验比较多。

#### 测试用例的力度

- 简单

  仅仅是测试的纲要，可能包含测试的内容。简单的测试用例其实并没有进行“设计”，而仅仅是记录。

- 复杂

  包含具体的输入项、每一个步骤、期待的结果。

- 中庸

  过于简单，会导致测试有遗漏，而且根据测试执行人员的水平不同导致偏差较大。过于复杂、会导致效率过低，维护成本较高，限制测试人员的思维， 一般在工作中都介于两者之间。

#### 测试用例设计方法总结

- 测试用例的本质(基于需求)

  - 理解需求  反映需求  忠于需求

  - 需求会变化，则测试用例也应该是活的、变化的

    $\color{red}“及时响应变更比遵循计划更有价值”$

- 原则

  1. 根据程序的重要性和一旦发生故障带来的损失，来确定测试等级和测试重点
  2. 认真选择测试策略。$\color{red}用尽可能少的测试用例来发现尽可能多的错误$。测试用例不足会导致风险的增大；测试过度导致资源的浪费。需要找到平衡点。

- 方法选取

  1. 先关注**主要功能 业务流程、业务逻辑**是否正确实现，考虑**场景法**
  2. 需要**输入数据**的地方，考虑**等价类划分法**
  3. 在任何情况下都使用**边界值法**
  4. 如果程序的功能中包含**输入条件的组合**情况，则选取**因果图和判定表法**
  5. 对于配置类软件，需要考虑**参数的组合**情况，考虑使用**正交排列法**
  6. 对照**程序逻辑**，如果发现**没有达到要求的覆盖标准**。适当补充更多的测试用例
  7. 采用错误推断法，追加其他测试用例。

### 测试用例设计步骤

1. 确定需求
2. 确定有效等价类和无效等价类
3. 对每条等价类设计测试用例

### 测试用例的评审

- 同行评审

  “个体和交互比过程和工具更有价值”

  由测试小组内部进行相互评审，达到思想的碰撞，通过探讨、协作完成测试用例的设计

- 用户评审

  “顾客的协作比合同谈判更有价值”

  - 如果测试是对产品的批判，则顾客指最终用户或者顾客代表

    在公司内部可以是市场调查人员或者相关领域专家

  - 如果测试是为软件开发提供帮助和支持，那么顾客就是程序员

## 缺陷

- 定义
  - 从内部看，软件缺陷是产品**开发或者维护过程中存在的错误、毛病**等各种问题
  - 从外部看，软件缺陷是系统所需要实现的某种功能的**失效或者违背**
  - 总的来说，缺陷就是问题，最终表现为所需要的功能**没有完全实现，没有满足用户**的需求。
- 具体包含(程序、数据、文档)
  - 未达到需求规格说明书中的功能
  - 出现了需求规格说明书中指明不会出现的错误
  - 功能超出了需求规格说明书的范围
  - 未达到需求规格说明书中虽然没有指明，但应该达到的目标
  - ==测试人员或者用户认为软件难以理解、不易使用、运行速度慢或者最终用户认为不好==
- 表现形式
  - 功能、特性没有实现或者部分实现
  - 设计不合理，功能特性不明确，逻辑不清楚或者存在矛盾
  - 产品实际结果和所期望的结果不一致
  - 没有达到需求规格说明书所规定的性能指标
  - 运行出错、中断、崩溃、界面混乱
  - 数据不正确、精度不够、不完整，格式不统一
  - 用户不能接受的其他问题，超时、界面丑陋
  - 硬件或者系统软件存在的其他问题
- 缺陷产生的原因
